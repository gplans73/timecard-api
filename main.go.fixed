package main

import (
    "bytes"
    "embed"
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "os"
    "sort"
    "strconv"
    "strings"
    "time"

    "github.com/xuri/excelize/v2"
)

//go:embed template.xlsx
var templateFS embed.FS

type EntryModel struct {
    ID           string  `json:"id"`
    Date         string  `json:"date"`
    JobNumber    string  `json:"jobNumber"`
    Code         string  `json:"code"`
    Hours        float64 `json:"hours"`
    Notes        string  `json:"notes"`
    IsOvertime   bool    `json:"isOvertime"`
    IsNightShift bool    `json:"isNightShift"`
}

type EmployeeInfo struct {
    Name  string `json:"name"`
    Email string `json:"email,omitempty"`
}

type PayPeriodInfo struct {
    WeekStart  string `json:"weekStart"`
    WeekEnd    string `json:"weekEnd"`
    WeekNumber int    `json:"weekNumber"`
    TotalWeeks int    `json:"totalWeeks"`
    PPNumber   int    `json:"ppNumber"`
    Year       int    `json:"year"`
}

type TimecardRequest struct {
    Employee  EmployeeInfo  `json:"employee"`
    Entries   []EntryModel  `json:"entries"`
    PayPeriod PayPeriodInfo `json:"payPeriod"`
}

func parseISO(d string) (time.Time, error) {
    formats := []string{
        time.RFC3339,
        "2006-01-02T15:04:05Z",
        "2006-01-02",
        "06-01-02",
        "2006/01/02",
        "01/02/2006",
        "02-01-2006",
        "02/01/2006",
    }
    for _, f := range formats {
        if t, err := time.ParseInLocation(f, d, time.Local); err == nil {
            return t, nil
        }
    }
    return time.Time{}, fmt.Errorf("bad date: %q", d)
}

func enableCORS(w http.ResponseWriter) {
    w.Header().Set("Access-Control-Allow-Origin", "*")
    w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
    w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
}

// Excel serial date
func timeToExcelDate(t time.Time) float64 {
    excelEpoch := time.Date(1899, 12, 30, 0, 0, 0, 0, t.Location())
    duration := t.Sub(excelEpoch)
    days := duration.Hours() / 24.0
    return float64(int64(days*1000000+0.5)) / 1000000
}

// setCellNumber sets a numeric value and ensures it has a numeric format
func setCellNumber(f *excelize.File, sheet, cell string, value interface{}) error {
    // Get the current style to preserve borders and alignment
    styleID, err := f.GetCellStyle(sheet, cell)
    if err != nil {
        styleID = 0
    }

    // Set the value first
    if err := f.SetCellValue(sheet, cell, value); err != nil {
        return err
    }

    // If the cell had a style, we need to ensure it's not text format
    if styleID != 0 {
        // Get the style
        style, err := f.GetStyle(styleID)
        if err == nil {
            // Check if it's a text format (NumFmt 49 or @)
            // If so, change it to General (1)
            if style.NumFmt == 49 {
                // Create a new style with the same properties but numeric format
                newStyle, _ := f.NewStyle(&excelize.Style{
                    NumFmt: 1, // 0 format (shows decimals like 0.50)
                    Alignment: style.Alignment,
                    Border:    style.Border,
                    Fill:      style.Fill,
                    Font:      style.Font,
                })
                return f.SetCellStyle(sheet, cell, cell, newStyle)
            }
        }
    }

    return nil
}

// fillWeekSheet populates a single week's sheet with data
func fillWeekSheet(f *excelize.File, weekNum int, weekStart, weekEnd time.Time, entries []EntryModel) error {
    sheetName := fmt.Sprintf("Week %d", weekNum)
    cell := func(col string, row int) string { return fmt.Sprintf("%s%d", col, row) }

    log.Printf("Filling %s with %d entries from %s to %s",
        sheetName, len(entries), weekStart.Format("2006-01-02"), weekEnd.Format("2006-01-02"))

    // Week start label (AJ4)
    _ = f.SetCellValue(sheetName, "AJ4", fmt.Sprintf("Week #%d", weekNum))

    // Styles
    dateStyle, _ := f.NewStyle(&excelize.Style{
        NumFmt: 14, // short date
        Alignment: &excelize.Alignment{
            Horizontal: "center",
            Vertical:   "center",
        },
        Border: []excelize.Border{
            {Type: "left", Color: "000000", Style: 1},
            {Type: "top", Color: "000000", Style: 1},
            {Type: "right", Color: "000000", Style: 1},
            {Type: "bottom", Color: "000000", Style: 1},
        },
    })

    // Header Info fields (M2: employee, AJ2: PPNumber, AJ3: Year, B4: week start as Excel serial, AJ4 already set)
    // M2, AJ2, AJ3 set by caller. Only B4 here:
    weekStartSerial := timeToExcelDate(weekStart)
    _ = setCellNumber(f, sheetName, "B4", weekStartSerial)
    _ = f.SetCellStyle(sheetName, "B4", "B4", dateStyle)

    // Column arrays for headers and data
    regularJobCols := []string{"D", "F", "H", "J", "L", "N", "P", "R", "T", "V", "X", "Z", "AB", "AD", "AF", "AH"}
    regularCodeCols := []string{"C", "E", "G", "I", "K", "M", "O", "Q", "S", "U", "W", "Y", "AA", "AC", "AE", "AG"}

    // Prepare job sets and grouping entries by day
    regularJobSet := make(map[string]struct{})
    overtimeJobSet := make(map[string]struct{})
    entryMap := make(map[int][]EntryModel)

    sort.Slice(entries, func(i, j int) bool {
        ti, _ := parseISO(entries[i].Date)
        tj, _ := parseISO(entries[j].Date)
        return ti.Before(tj)
    })

    for _, e := range entries {
        dt, err := parseISO(e.Date)
        if err != nil {
            continue
        }
        dayIdx := int(dt.Sub(weekStart).Hours()/24 + 0.0001)
        if dayIdx < 0 || dayIdx > 6 {
            log.Printf("Entry date %s outside week range, skipping", dt.Format("2006-01-02"))
            continue
        }
        entryMap[dayIdx] = append(entryMap[dayIdx], e)

        k := e.JobNumber + "-" + e.Code
        if e.IsOvertime {
            overtimeJobSet[k] = struct{}{}
        } else {
            regularJobSet[k] = struct{}{}
        }
    }

    // Sorted job lists
    var regularJobs []string
    for k := range regularJobSet {
        regularJobs = append(regularJobs, k)
    }
    sort.Strings(regularJobs)

    var overtimeJobs []string
    for k := range overtimeJobSet {
        overtimeJobs = append(overtimeJobs, k)
    }
    sort.Strings(overtimeJobs)

    log.Printf("Week %d has %d regular jobs: %v", weekNum, len(regularJobs), regularJobs)
    log.Printf("Week %d has %d overtime jobs: %v", weekNum, len(overtimeJobs), overtimeJobs)

    // --- Regular job headers row 4 ---
    for i, key := range regularJobs {
        if i >= len(regularJobCols) {
            log.Printf("Warning: More than %d jobs, truncating", len(regularJobCols))
            break
        }
        parts := strings.SplitN(key, "-", 2)
        job, code := parts[0], ""
        if len(parts) > 1 {
            code = parts[1]
        }

        // Code cell (C4, E4, G4, ... AE4 odd columns)
        codeCell := cell(regularCodeCols[i], 4)
        if num, err := strconv.ParseInt(code, 10, 64); err == nil && !(len(code) > 1 && code[0] == '0') {
            _ = setCellNumber(f, sheetName, codeCell, num)
        } else {
            _ = f.SetCellValue(sheetName, codeCell, code)
        }

        // Job number cell (D4, F4, H4, ... AH4 even columns)
        jobCell := cell(regularJobCols[i], 4)
        if num, err := strconv.ParseInt(job, 10, 64); err == nil && !(len(job) > 1 && job[0] == '0') {
            _ = setCellNumber(f, sheetName, jobCell, num)
        } else {
            _ = f.SetCellValue(sheetName, jobCell, job)
        }
    }

    // --- Regular daily data rows 5-11 ---
    for day := 0; day < 7; day++ {
        row := 5 + day
        dayDate := weekStart.AddDate(0, 0, day)
        dateSerial := timeToExcelDate(dayDate)
        _ = setCellNumber(f, sheetName, cell("B", row), dateSerial)
        _ = f.SetCellStyle(sheetName, cell("B", row), cell("B", row), dateStyle)

        // Map job key to total hours for that day (regular only)
        reg := make(map[string]float64)
        for _, e := range entryMap[day] {
            if e.IsOvertime {
                continue
            }
            k := e.JobNumber + "-" + e.Code
            reg[k] += e.Hours
        }

        // Write hours ONLY to job number columns (D,F,H,...,AH)
        for j, k := range regularJobs {
            if j >= len(regularJobCols) {
                break
            }
            hrs := reg[k]
            if hrs > 0 {
                addr := cell(regularJobCols[j], row)
                _ = setCellNumber(f, sheetName, addr, hrs)
            }
        }
    }

    // --- Overtime job headers row 15 ---
    if len(overtimeJobs) > 0 {
        for i, key := range overtimeJobs {
            if i >= len(regularJobCols) {
                break
            }
            parts := strings.SplitN(key, "-", 2)
            job, code := parts[0], ""
            if len(parts) > 1 {
                code = parts[1]
            }

            // Code cell row 15 (C15, E15, G15, ... AE15 odd columns)
            codeCell := cell(regularCodeCols[i], 15)
            if num, err := strconv.ParseInt(code, 10, 64); err == nil && !(len(code) > 1 && code[0] == '0') {
                _ = setCellNumber(f, sheetName, codeCell, num)
            } else {
                _ = f.SetCellValue(sheetName, codeCell, code)
            }

            // Job number cell row 15 (D15, F15, H15, ... AH15 even columns)
            jobCell := cell(regularJobCols[i], 15)
            if num, err := strconv.ParseInt(job, 10, 64); err == nil && !(len(job) > 1 && job[0] == '0') {
                _ = setCellNumber(f, sheetName, jobCell, num)
            } else {
                _ = f.SetCellValue(sheetName, jobCell, job)
            }
        }
    }

    // --- Overtime daily data rows 16-22 ---
    for day := 0; day < 7; day++ {
        row := 16 + day
        dayDate := weekStart.AddDate(0, 0, day)
        dateSerial := timeToExcelDate(dayDate)
        _ = setCellNumber(f, sheetName, cell("B", row), dateSerial)
        _ = f.SetCellStyle(sheetName, cell("B", row), cell("B", row), dateStyle)

        ot := make(map[string]float64)
        for _, e := range entryMap[day] {
            if !e.IsOvertime {
                continue
            }
            k := e.JobNumber + "-" + e.Code
            ot[k] += e.Hours
        }

        // Write hours ONLY to job number columns (D,F,H,...,AH)
        for j, k := range overtimeJobs {
            if j >= len(regularJobCols) {
                break
            }
            hrs := ot[k]
            if hrs > 0 {
                addr := cell(regularJobCols[j], row)
                _ = setCellNumber(f, sheetName, addr, hrs)
            }
        }
    }

    return nil
}

func sumMap(m map[string]float64) float64 {
    var sum float64
    for _, v := range m {
        sum += v
    }
    return sum
}

func generateTimecardHandler(w http.ResponseWriter, r *http.Request) {
    enableCORS(w)
    if r.Method == http.MethodOptions {
        w.WriteHeader(http.StatusNoContent)
        return
    }
    if r.Method != http.MethodPost {
        http.Error(w, "use POST", http.StatusMethodNotAllowed)
        return
    }

    var req TimecardRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        log.Printf("JSON decode error: %v", err)
        http.Error(w, "bad json: "+err.Error(), http.StatusBadRequest)
        return
    }
    if len(req.Entries) == 0 {
        http.Error(w, "no entries provided", http.StatusBadRequest)
        return
    }

    ws, err := parseISO(req.PayPeriod.WeekStart)
    if err != nil {
        http.Error(w, "bad weekStart", http.StatusBadRequest)
        return
    }
    we, err := parseISO(req.PayPeriod.WeekEnd)
    if err != nil {
        http.Error(w, "bad weekEnd", http.StatusBadRequest)
        return
    }

    daysDiff := int(we.Sub(ws).Hours() / 24)
    isFullPayPeriod := daysDiff >= 13
    log.Printf("Date range: %s to %s (%d days)", ws.Format("2006-01-02"), we.Format("2006-01-02"), daysDiff)
    log.Printf("Full pay period mode: %v", isFullPayPeriod)

    year := req.PayPeriod.Year
    if year == 0 {
        year = ws.Year()
    }

    // Load template
    raw, err := templateFS.ReadFile("template.xlsx")
    if err != nil {
        http.Error(w, "template read: "+err.Error(), http.StatusInternalServerError)
        return
    }
    f, err := excelize.OpenReader(bytes.NewReader(raw))
    if err != nil {
        http.Error(w, "open xlsx: "+err.Error(), http.StatusInternalServerError)
        return
    }
    defer f.Close()

    // Employee info M2
    if req.Employee.Name != "" {
        _ = f.SetCellValue("Week 1", "M2", req.Employee.Name)
        _ = f.SetCellValue("Week 2", "M2", req.Employee.Name)
    }
    // PPNumber AJ2
    if req.PayPeriod.PPNumber > 0 {
        _ = setCellNumber(f, "Week 1", "AJ2", req.PayPeriod.PPNumber)
        _ = setCellNumber(f, "Week 2", "AJ2", req.PayPeriod.PPNumber)
    }
    // Year AJ3
    _ = setCellNumber(f, "Week 1", "AJ3", year)
    _ = setCellNumber(f, "Week 2", "AJ3", year)

    // Split entries
    var week1Entries, week2Entries []EntryModel
    week1End := ws.AddDate(0, 0, 6)
    week2Start := ws.AddDate(0, 0, 7)

    for _, e := range req.Entries {
        dt, err := parseISO(e.Date)
        if err != nil {
            log.Printf("Could not parse date '%s': %v", e.Date, err)
            continue
        }
        if !dt.Before(ws) && !dt.After(week1End) {
            week1Entries = append(week1Entries, e)
        } else if !dt.Before(week2Start) && !dt.After(we) {
            week2Entries = append(week2Entries, e)
        }
    }

    if len(week1Entries) > 0 {
        if err := fillWeekSheet(f, 1, ws, week1End, week1Entries); err != nil {
            http.Error(w, fmt.Sprintf("error processing Week 1: %v", err), http.StatusInternalServerError)
            return
        }
    }
    if len(week2Entries) > 0 {
        if err := fillWeekSheet(f, 2, week2Start, we, week2Entries); err != nil {
            http.Error(w, fmt.Sprintf("error processing Week 2: %v", err), http.StatusInternalServerError)
            return
        }
    }

    buf, err := f.WriteToBuffer()
    if err != nil {
        http.Error(w, "write xlsx: "+err.Error(), http.StatusInternalServerError)
        return
    }

    w.Header().Set("Content-Type", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
    w.Header().Set("Content-Disposition", `attachment; filename="Timecard.xlsx"`)
    w.Header().Set("Content-Length", fmt.Sprintf("%d", buf.Len()))
    w.WriteHeader(http.StatusOK)
    _, _ = w.Write(buf.Bytes())
}

func healthHandler(w http.ResponseWriter, r *http.Request) {
    enableCORS(w)
    w.WriteHeader(http.StatusOK)
    _, _ = w.Write([]byte("OK"))
}

func main() {
    http.HandleFunc("/api/generate-timecard", generateTimecardHandler)
    http.HandleFunc("/health", healthHandler)

    port := os.Getenv("PORT")
    if port == "" {
        port = "8080"
    }
    log.Printf("Server starting on port %s", port)
    log.Fatal(http.ListenAndServe(":"+port, nil))
}
